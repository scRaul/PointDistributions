<html>

<head>
<title>Functions</title>


<!-- vertex shader - Our part in the geometry processing part of the pipeline happens here -->

<script id="shader-vs" type="x-shader/x-vertex">

    attribute vec3 aVertexPosition;

    void main(){
        gl_Position = vec4(aVertexPosition,1.0);
        gl_PointSize = 2.0;
    }
</script>

<!-- fragment shader - Pixel color is determined here -->
<script id="shader-fs" type="x-shader/x-fragment">

    void main(void) {
        gl_FragColor = vec4(1.0,1.0,0.0,1.0);
    }
</script>

<script type="text/javascript">

    var gl;

    // the shader that will be used by each piece of geometry (they could each use their own shader but in this case it will be the same)
    var shaderProgram;
    var canvas;

    // ------------------------------------------------------------------------
    function initializeAndStartRendering() {
        initGL();
        // uncomment when directed by the guide
        document.getElementById('inp').value = 1;
        document.getElementsByName('Shape')[0].checked = "checked";
        document.getElementsByName('type')[0].checked = "checked";
        
        createShaders();
        if (gl) {
            updateAndRender();
        }
    }

    // -----------------------------------------------------------------------
    function initGL() {
        
        canvas = document.getElementById("webgl-canvas");
        
        try {
            gl = canvas.getContext("webgl");

            // Note: gl does not naturally have canvasWidth or canvasHeight
            // We are attaching them to the object for convenience

            gl.canvasWidth = canvas.width;
            gl.canvasHeight = canvas.height;

        } catch (e) {}

        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    // -------------------------------------------------------------------------
    function createShaders() {
       
        var vertexShaderText = document.getElementById('shader-vs').textContent;
        var vertexShader = createCompiledShader(gl, vertexShaderText, gl.VERTEX_SHADER);

        var fragmentShaderText = document.getElementById('shader-fs').textContent;
        var fragmentShader = createCompiledShader(gl, fragmentShaderText, gl.FRAGMENT_SHADER);

     
        // Create an empty gl "program" which will be composed of compiled shaders
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);

        // Tell gl it's ready to go, link it
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.attributes = {
            vertexPositionAttribute: gl.getAttribLocation(shaderProgram, "aVertexPosition"),
         };

    }

    // -----------------------------------------------------------------------
     
    function createCompiledShader(gl, shaderText, shaderType) {
         var shader = gl.createShader(shaderType);
    
         gl.shaderSource(shader,shaderText);
         gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            console.log(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    function initVertexBuffers(n){
        var e = document.getElementsByName('Shape');
        var vertices;
        if(e[0].checked)
            vertices = new Float32Array(makeLine(n));
        else if(e[1].checked)
            vertices = new Float32Array(makeExp(n));
        else if( e[2].checked)
            vertices = new Float32Array(makeCos(n));
        else if(e[3].checked)
            vertices = new Float32Array(flower(n));
        else
            vertices = new Float32Array(turnFraction(n));
        

        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);

        gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,2,gl.FLOAT,false,0,0);
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        //return n*n;
        return vertices.length/2;
    }

    function makeExp(n){
        var step = .1/n;
        if(step == 0) step = .1;
        if(step < 0) step *= -1;
        var points = [];

        for(let i = -1; i < 1; i +=step){
            var x = i; 
            var y = Math.pow(x,n);
            points.push(x);points.push(y);
        }
    
   
        return points;

    }
    function makeLine(n){
        
        var step = .1/n;
        if(step == 0) step = .1;
        if(step < 0) step *= -1;
        var points = [];

        for(let i = -1; i < 1; i +=step){
            var x = i; 
            var y = n * x;
            points.push(x);points.push(y);
        }
    

        //console.log(points.length/2);
        return points;
    }
    function makeCos(n){
        var step = .1/n;
        if(step == 0) step = .1;
        if(step < 0) step *= -1;
        var points = [];

        for(let i = -1; i < 1; i +=step){
            var x = i; 
            var y = (1/(2))*Math.cos(n*x);
            points.push(x);points.push(y);
        }
        return points;

    }
    function flower(n){
        var a = 1;
        var points = [];
        var step = Math.PI/180;
        for( let i = 0; i < 2 * Math.PI; i+= step){
            var x =  a*Math.cos(n*i) * Math.cos(i);
            var y =  a*Math.cos(n*i) * Math.sin(i);

            points.push(x);points.push(y);
        }


        return points;
    }
    function turnFraction(n){
        //var turnFraction = ( (1 + Math.sqrt(5)) / 2 ) ;
        var turnFraction = n;
        var p = 1000;
        var points = [];
        for(let i = 0; i < p; i++){
            var dst =  Math.sqrt(i / (p - 1.0)) ;
            var angle = 2 * Math.PI * turnFraction * i;

            var x = dst * Math.cos(angle );
            var y = dst * Math.sin(angle );

            points.push(x);points.push(y);

        }
        return points;
    }
    function updateAndRender() {
       // requestAnimationFrame(updateAndRender);

        gl.viewport(0, 0,canvas.width ,canvas.height );
        // this is a new frame so let's clear out whatever happened last frame
        var n = (document.getElementById('inp').value);
        if(n == null) n = 1;


        n = initVertexBuffers(n);
        gl.clearColor(0.0, 0.0,0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var e = document.getElementsByName('type');
        if(e[0].checked)
            gl.drawArrays(gl.POINTS,0,n);
        else if(e[1].checked)
            gl.drawArrays(gl.LINE_STRIP,0,n);
        
        //gl.drawArrays(gl.LINES,n,4);

        
    }

    // -------------------------------------------------------------------------

</script>
    
 <link href="style.css" rel="stylesheet" type="text/css" />

</head>


<body onload="initializeAndStartRendering();">
    
    <nav>
        <ul>
            <li> <a href="index.html"> Distributions </a></li>
             <li> <a href="curves.html"> Curves/Functions </a></li>
        </ul>
    </nav>

    <canvas class="center" id="webgl-canvas" style="border: none;" width="512" height="512"></canvas>
        
        <input type="radio" id="Points" name="type"  onclick="updateAndRender();" >
        <label for="Triangle">Points</label>

        <input type="radio" id="Lines" name="type"onclick="updateAndRender();"  >
        <label for="Square">Line Strip</label>
    
        <label id="la">Enter a number: </label>
        <input class="center" name="inp" id="inp" type="number" onchange="updateAndRender();">

        <input type="radio" id="Triangle" name="Shape"  onclick="updateAndRender();" >
        <label for="Triangle">Linear</label>

        <input type="radio" id="Square" name="Shape"onclick="updateAndRender();"  >
        <label for="Square">Exponential</label>

        <input type="radio" id="Rings" name="Shape"onclick="updateAndRender();"  >
        <label for="Square">Wave</label>

        <input type="radio" id="sunflower" name="Shape"onclick="updateAndRender();"  >
        <label for="Square">Flower</label>

        <input type="radio" id="turnFraction" name="Shape"onclick="updateAndRender();"  >
        <label for="Square">Turn Fraction</label>
</body>

</html>
